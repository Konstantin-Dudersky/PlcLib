FUNCTION_BLOCK "SF_Equivalent"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      Activate { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      S_ChannelA { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      S_ChannelB { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DiscrepancyTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
   END_VAR

   VAR_OUTPUT 
      Ready { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      S_EquivalentOut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      SafetyDemand { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      Error { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      DiagCode { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
   END_VAR

   VAR 
      SM { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "StateMachine";
   END_VAR

   VAR CONSTANT 
      ST_IDLE : Int;
      ST_INIT : Int := 1;
      ST_WAITB : Int := 2;
      ST_WAITA : Int := 3;
      ST_ERROR12 : Int := 4;
      ST_ENABLE : Int := 7;
      ST_WAITFROMACTIVE : Int := 6;
      ST_ERROR3 : Int := 5;
   END_VAR


BEGIN
	#SM.aTr[#ST_IDLE, #ST_INIT] := "SM_Trans"(C := #Activate, P := 0);
	
	#SM.aTr[#ST_INIT, #ST_IDLE] := "SM_Trans"(C := NOT #Activate, P := 0);
	#SM.aTr[#ST_INIT, #ST_WAITB] := "SM_Trans"(C := #S_ChannelA AND NOT #S_ChannelB, P := 1);
	#SM.aTr[#ST_INIT, #ST_WAITA] := "SM_Trans"(C := NOT #S_ChannelA AND #S_ChannelB, P := 2);
	#SM.aTr[#ST_INIT, #ST_ENABLE] := "SM_Trans"(C := #S_ChannelA AND #S_ChannelB, P := 3);
	
	#SM.aTr[#ST_WAITB, #ST_IDLE] := "SM_Trans"(C := NOT #Activate, P := 0);
	#SM.aTr[#ST_WAITB, #ST_ERROR12] := "SM_Trans"(C := #SM.timState >= #DiscrepancyTime, P := 1);
	#SM.aTr[#ST_WAITB, #ST_INIT] := "SM_Trans"(C := NOT #S_ChannelA, P := 2);
	#SM.aTr[#ST_WAITB, #ST_ENABLE] := "SM_Trans"(C := #S_ChannelB, P := 3);
	
	#SM.aTr[#ST_WAITA, #ST_IDLE] := "SM_Trans"(C := NOT #Activate, P := 0);
	#SM.aTr[#ST_WAITA, #ST_ERROR12] := "SM_Trans"(C := #SM.timState >= #DiscrepancyTime, P := 1);
	#SM.aTr[#ST_WAITA, #ST_INIT] := "SM_Trans"(C := NOT #S_ChannelB, P := 2);
	#SM.aTr[#ST_WAITA, #ST_ENABLE] := "SM_Trans"(C := #S_ChannelA, P := 3);
	
	#SM.aTr[#ST_ERROR12, #ST_IDLE] := "SM_Trans"(C := NOT #Activate, P := 0);
	#SM.aTr[#ST_ERROR12, #ST_INIT] := "SM_Trans"(C := NOT #S_ChannelA AND NOT #S_ChannelB, P := 1);
	
	#SM.aTr[#ST_ENABLE, #ST_IDLE] := "SM_Trans"(C := NOT #Activate, P := 0);
	#SM.aTr[#ST_ENABLE, #ST_WAITFROMACTIVE] := "SM_Trans"(C := #S_ChannelA XOR #S_ChannelB, P := 1);
	#SM.aTr[#ST_ENABLE, #ST_INIT] := "SM_Trans"(C := NOT #S_ChannelA AND NOT #S_ChannelB, P := 2);
	
	#SM.aTr[#ST_WAITFROMACTIVE, #ST_IDLE] := "SM_Trans"(C := NOT #Activate, P := 0);
	#SM.aTr[#ST_WAITFROMACTIVE, #ST_ERROR3] := "SM_Trans"(C := #SM.timState >= #DiscrepancyTime, P := 1);
	#SM.aTr[#ST_WAITFROMACTIVE, #ST_INIT] := "SM_Trans"(C := NOT #S_ChannelA AND NOT #S_ChannelB, P := 2);
	
	#SM.aTr[#ST_ERROR3, #ST_IDLE] := "SM_Trans"(C := NOT #Activate, P := 0);
	#SM.aTr[#ST_ERROR3, #ST_INIT] := "SM_Trans"(C := NOT #S_ChannelA AND NOT #S_ChannelB, P := 1);
	
	#SM();
	
	CASE #SM.iState OF
	    #ST_IDLE:
	        #DiagCode := 16#0000;
	        
	    #ST_ENABLE:
	        #DiagCode := 16#8000;
	        
	    #ST_INIT:
	        #DiagCode := 16#8801;
	        
	    #ST_WAITB:
	        #DiagCode := 16#8802;
	        
	    #ST_WAITA:
	        #DiagCode := 16#8804;
	        
	    #ST_WAITFROMACTIVE:
	        #DiagCode := 16#8806;
	        
	    #ST_ERROR12:
	        IF #SM.xStateFirstCall THEN
	            IF #SM.iStatePrev = #ST_WAITB THEN
	                #DiagCode := 16#C010;
	            ELSIF #SM.iStatePrev = #ST_WAITA THEN
	                #DiagCode := 16#C020;
	            END_IF;
	        END_IF;
	
	    #ST_ERROR3:
	        #DiagCode := 16#C030;
	        
	END_CASE;
	
	#Ready := #SM.iState <> #ST_IDLE;
	#S_EquivalentOut := #SM.iState = #ST_ENABLE;
	#SafetyDemand := #SM.iState = #ST_INIT OR #SM.iState = #ST_WAITB OR #SM.iState = #ST_WAITA OR #SM.iState = #ST_WAITFROMACTIVE;
	#Error := #DiagCode = 16#C010 OR #DiagCode = 16#C020 OR #DiagCode = 16#C030;
END_FUNCTION_BLOCK

