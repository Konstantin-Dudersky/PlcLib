FUNCTION "Error" : Void
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Condition : Bool;
      NewSubfunction : Word;
      NewErrorId : Word;
   END_VAR

   VAR_IN_OUT 
      Error : Bool;
      ErrorId : DWord;
   END_VAR

   VAR_TEMP 
      tmpDw : DWord;
      tmpDwAt AT tmpDw : Array[0..1] of Word;
   END_VAR


BEGIN
	IF #Condition AND NOT #Error THEN
	    #Error := true;
	    #tmpDwAt[0] := INT_TO_WORD(#NewSubfunction);
	    #tmpDwAt[1] := #NewErrorId;
	    #ErrorId := #tmpDw;
	END_IF;
END_FUNCTION

FUNCTION_BLOCK "StateMachine"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      aTr { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[0..#MAX_INDEX, 0..#MAX_INDEX] of Byte;
   END_VAR

   VAR_OUTPUT 
      iState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      iStatePrev { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      iStateNext { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      xStateFirstCall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      xStateLastCall { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      timState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      xError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      dwErrorId { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DWord;
   END_VAR

   VAR 
      stat { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
         prev { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Struct
            iState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         END_STRUCT;
         timSampleTime { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
         iStateNext { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
         xInitialized { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      temp : Struct
         TopSiNone {InstructionName := 'SI_none'; LibVersion := '1.0'} : SI_none;
         TopSiCyclic {InstructionName := 'SI_Cyclic'; LibVersion := '1.0'} : SI_Cyclic;
         TopSiProgramCycle {InstructionName := 'SI_ProgramCycle'; LibVersion := '1.0'} : SI_ProgramCycle;
         StartUpSi {InstructionName := 'SI_Startup'; LibVersion := '1.0'} : SI_Startup;
         TempInt : Int;
         TempWord : Word;
         TempUdint : UDInt;
         SampleTime : UDInt;
         xTransCond : Bool;
         usiTransPrio : USInt;
         usiBestPrio : USInt;
      END_STRUCT;
      i : Int;
      tempBy : Byte;
      tempByAt AT tempBy : Array[0..7] of Bool;
   END_VAR

   VAR CONSTANT 
      MAX_INDEX : Int := 19;
      EID_RD_SINFO : Word := 16#2;
      EID_QRY_CINT : Word := 16#3;
   END_VAR


BEGIN
	(*
	TODO - из одного состояния нет переходов с одинаковым приоритетом
	TODO - обнуление массива переходов при первой инициализации
	*)
	
	IF NOT #stat.xInitialized THEN
	    // определяем OB_Class вызывающего блока
	    #temp.TempInt := RD_SINFO(TOP_SI => #temp.TopSiNone, START_UP_SI => #temp.StartUpSi);
	    
	    "Error"(Condition := #temp.TempInt <> 16#0,
	            NewSubfunction := #EID_RD_SINFO,
	            NewErrorId := INT_TO_WORD(#temp.TempInt),
	            Error := #xError,
	            ErrorId := #dwErrorId);
	    
	    CASE #temp.TopSiNone.OB_Class OF
	        1:
	            #temp.TempInt := RD_SINFO(TOP_SI => #temp.TopSiProgramCycle, START_UP_SI => #temp.StartUpSi);
	            "Error"(Condition := #temp.TempInt <> 16#0,
	                    NewSubfunction := #EID_RD_SINFO,
	                    NewErrorId := INT_TO_WORD(#temp.TempInt),
	                    Error := #xError,
	                    ErrorId := #dwErrorId);
	            
	            #stat.timSampleTime := T#0ms;
	            
	        30:
	            #temp.TempInt := RD_SINFO(TOP_SI => #temp.TopSiCyclic, START_UP_SI => #temp.StartUpSi);
	            "Error"(Condition := #temp.TempInt <> 16#0,
	                    NewSubfunction := #EID_RD_SINFO,
	                    NewErrorId := INT_TO_WORD(#temp.TempInt),
	                    Error := #xError,
	                    ErrorId := #dwErrorId);
	            
	            #temp.TempInt := QRY_CINT(OB_NR := UINT_TO_INT(#temp.TopSiCyclic.OB_Nr), CYCLE => #temp.SampleTime, PHASE => #temp.TempUdint, STATUS => #temp.TempWord);
	            "Error"(Condition := #temp.TempInt <> 16#0,
	                    NewSubfunction := #EID_QRY_CINT,
	                    NewErrorId := INT_TO_WORD(#temp.TempInt),
	                    Error := #xError,
	                    ErrorId := #dwErrorId);
	            
	            #stat.timSampleTime := UDINT_TO_TIME(#temp.SampleTime / 1000);
	    END_CASE;
	    
	    // если нет ошибок, заканчиваем инициализацию
	    #stat.xInitialized := NOT #xError;
	ELSE
	
	    // проверяем переходы
	    IF #iState = #stat.iStateNext THEN
	        #temp.usiBestPrio := 15;
	        
	        FOR #i := 0 TO #MAX_INDEX DO
	            #tempBy := #aTr[#iState, #i];
	            #temp.xTransCond := #tempByAt[7];
	            #tempByAt[7] := 0;
	            #temp.usiTransPrio := BYTE_TO_USINT(#tempBy);
	            
	            IF #temp.xTransCond AND #temp.usiTransPrio < #temp.usiBestPrio THEN
	                #stat.iStateNext := #i;
	                #temp.usiBestPrio := #temp.usiTransPrio;
	            END_IF;
	        END_FOR;
	        
	        #timState += #stat.timSampleTime;
	    ELSE
	        #iState := #stat.iStateNext;
	        
	        #timState := T#0ms;
	    END_IF;
	    
	    #xStateFirstCall := #iState <> #stat.prev.iState;
	    IF #xStateFirstCall THEN
	        #iStatePrev := #stat.prev.iState;
	    END_IF;
	    
	    #xStateLastCall := #iState <> #stat.iStateNext;
	    IF #xStateLastCall THEN
	        #iStateNext := #stat.iStateNext;
	    END_IF;
	    
	    #stat.prev.iState := #iState;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION "SM_Trans" : Byte
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      C : Bool;   // условие перехода
      P : USInt;   // приоритет (0 - наивысший)
   END_VAR

   VAR_TEMP 
      tmp : Struct
         usiPrio : USInt;
      END_STRUCT;
      tmpByte : Byte;
      tmpByteAt AT tmpByte : Array[0..7] of Bool;
      tmpOut : Byte;
      tmpOutAt AT tmpOut : Array[0..7] of Bool;
   END_VAR


BEGIN
	IF #P >= 15 THEN
	    #tmp.usiPrio := 15;
	ELSE
	    #tmp.usiPrio := #P;
	END_IF;
	
	#tmpByte := USINT_TO_BYTE(#tmp.usiPrio);
	
	#tmpOut := #tmpByte;
	#tmpOutAt[7] := #C;
	
	#SM_Trans := #tmpOut;
END_FUNCTION

FUNCTION "@StateMachine" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	(*
	
	Экспорт в StateMachine/StateMachine.scl
	
	
	
	
	
	
	
	
	
	*)
END_FUNCTION

